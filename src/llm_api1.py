from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import os, time
from datetime import datetime
from src.metrics import record_metric

# === LLM + MCP Imports ===
from langchain_ollama import ChatOllama
from langchain_mcp_adapters.client import MultiServerMCPClient
from langchain_mcp_adapters.tools import load_mcp_tools

# === LangGraph / React-Agent Imports ===
from langchain_core.messages import SystemMessage, HumanMessage
from langgraph.prebuilt import create_react_agent

# Optional: debug callback for tool tracing
from langchain.callbacks.base import BaseCallbackHandler
from langchain.callbacks.manager import CallbackManager

class DebugCallbackHandler(BaseCallbackHandler):
    def on_tool_start(self, serialized, input_str, **kwargs):
        print(f"ðŸ”§ TOOL START â†’ {serialized['name']}({input_str})")
    def on_tool_end(self, serialized, output, **kwargs):
        print(f"âœ… TOOL END   â†’ {serialized['name']} â†’ {output}")

app = FastAPI()
OLLAMA_MODEL = os.getenv("OLLAMA_MODEL", "llama3.2:3b")
MCP_URL       = os.getenv("MCP_URL",       "http://mcp_server:8000")

class PromptRequest(BaseModel):
    prompt: str

def now_timestamp() -> str:
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

@app.on_event("startup")
async def startup_event():
    llm = ChatOllama(model=OLLAMA_MODEL, base_url="http://ollama:11434")
    llm.invoke("hi")

    mcp_client = MultiServerMCPClient({
        "database": {"transport": "streamable_http", "url": f"{MCP_URL}/mcp/"}
    })
    mcp_ctx = mcp_client.session("database")
    session = await mcp_ctx.__aenter__()
    await session.initialize()

    tools = await load_mcp_tools(session)
    print("Loaded MCP tools:", [t.name for t in tools])

    system_prompt = SystemMessage(content="""
        You are a SQL agent over a database exposed via MCP.
        1) Always call list_tables first.
        2) Inspect only relevant tables via get_table_schema or get_usable_table_names.
        3) Double-check your SQL with the checker tool if available.
        4) Execute your SQL via execute_query and return up to 5 rows (unless asked otherwise).
        5) **Never use `SELECT *`; always explicitly list only the columns needed.**
        If you hit an error, regenerate and retry. No INSERT/UPDATE/DELETE.
        """)
    cbmgr = CallbackManager([DebugCallbackHandler()])
    agent = create_react_agent(
        llm,
        tools,
        state_modifier=system_prompt,
        callback_manager=cbmgr,
        debug=False
    )

    app.state.agent       = agent
    app.state.mcp_context = mcp_ctx
    print("ðŸš€ Agent executor ready")

@app.on_event("shutdown")
async def shutdown_event():
    await app.state.mcp_context.__aexit__(None, None, None)

@app.post("/ask")
async def ask_sql(req: PromptRequest):
    ts = now_timestamp()
    start = time.perf_counter()

    try:
        # Invoke the agent with the user prompt (which may list tables, inspect schema, and generate SQL)
        resp = await app.state.agent.ainvoke({
            "messages": [HumanMessage(content=req.prompt)]
        })
        duration = time.perf_counter() - start

        # record metrics
        record_metric(
            prompt=req.prompt,
            start_ts=start,
            success=True,
            error_msg="",
            iterations=len(getattr(resp, "steps", [])),
            function_times={s.tool_name: s.execution_time for s in getattr(resp, "steps", [])}
        )
        
        print("ðŸ“¦ Full response:", resp)

        # Extract the SQL generated by the agent via the execute_query tool
        generated_sql = None
        for step in getattr(resp, 'steps', []):
            if step.tool_name == 'execute_query':
                # tool input carries the SQL string
                # depending on adapter, it may be step.kwargs['sql'] or step.input
                try:
                    generated_sql = step.kwargs.get('sql') or step.input
                except Exception:
                    generated_sql = step.input
                break

        return {
            "status": "success",
            "timestamp": ts,
            "generated_sql": generated_sql,
            "response": resp
        }

    except Exception as e:
        record_metric(
            prompt=req.prompt,
            start_ts=start,
            success=False,
            error_msg=str(e),
            iterations=0,
            function_times={}
        )
        raise HTTPException(status_code=500, detail=str(e))
